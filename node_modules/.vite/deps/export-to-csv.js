import "./chunk-HKJ2B2AA.js";

// node_modules/export-to-csv/output/index.js
var v = { fieldSeparator: ",", decimalSeparator: ".", quoteStrings: true, quoteCharacter: '"', showTitle: false, title: "My Generated Report", filename: "generated", showColumnHeaders: true, useTextFile: false, useBom: true, columnHeaders: [], useKeysAsHeaders: false, boolDisplay: { true: "TRUE", false: "FALSE" }, replaceUndefinedWith: "" };
var F = "\r\n";
var S = "\uFEFF";
var Z = (x) => Object.assign({}, v, x);
var _ = class extends Error {
  constructor(x) {
    super(x);
    this.name = "CsvGenerationError";
  }
};
var $ = class extends Error {
  constructor(x) {
    super(x);
    this.name = "EmptyHeadersError";
  }
};
var M = class extends Error {
  constructor(x) {
    super(x);
    this.name = "CsvDownloadEnvironmentError";
  }
};
var X = (x) => x;
var z = (x) => x;
var Y = X;
var W = X;
var Q = X;
var T = X;
var w = function(x, A) {
  if (A == '"' && x.indexOf('"') > -1) return x.replace(/"/g, '""');
  return x;
};
var H = (x) => typeof x === "object" ? Q(x.key) : Q(x);
var D = (x) => typeof x === "object" ? T(x.displayLabel) : T(x);
var K = (x, ...A) => A.reduce((N, j) => j(N), x);
var L = (x) => (A) => x.useBom ? Y(z(A) + S) : A;
var P = (x) => (A) => x.showTitle ? q(Y(z(A) + x.title))(W("")) : A;
var q = (x) => (A) => Y(z(x) + z(A) + F);
var O = (x) => (A, N) => h(x)(W(A + N));
var h = (x) => (A) => X(z(A) + x.fieldSeparator);
var R = (x, A) => (N) => {
  if (!x.showColumnHeaders) return N;
  if (A.length < 1) throw new $("Option to show headers but none supplied. Make sure there are keys in your collection or that you've supplied headers through the config options.");
  let j = W("");
  for (let G = 0; G < A.length; G++) {
    const J = D(A[G]);
    j = O(x)(j, C(x, J));
  }
  return j = W(z(j).slice(0, -1)), q(N)(j);
};
var E = (x, A, N) => (j) => {
  let G = j;
  for (var J = 0; J < N.length; J++) {
    let U = W("");
    for (let I = 0; I < A.length; I++) {
      const B = H(A[I]), b = typeof N[J][z(B)] === "undefined" ? x.replaceUndefinedWith : N[J][z(B)];
      U = O(x)(U, C(x, b));
    }
    U = W(z(U).slice(0, -1)), G = q(G)(U);
  }
  return G;
};
var y = z;
var V = (x) => +x === x && (!isFinite(x) || Boolean(x % 1));
var C = (x, A) => {
  if (x.decimalSeparator === "locale" && V(A)) return A.toLocaleString();
  if (x.decimalSeparator !== "." && V(A)) return A.toString().replace(".", x.decimalSeparator);
  if (typeof A === "string") {
    let N = A;
    if (x.quoteStrings || x.fieldSeparator && A.indexOf(x.fieldSeparator) > -1 || x.quoteCharacter && A.indexOf(x.quoteCharacter) > -1 || A.indexOf("\n") > -1 || A.indexOf("\r") > -1) N = x.quoteCharacter + w(A, x.quoteCharacter) + x.quoteCharacter;
    return N;
  }
  if (typeof A === "boolean" && x.boolDisplay) {
    const N = A ? "true" : "false";
    return x.boolDisplay[N];
  }
  return A;
};
var Gx = (x) => (A) => {
  const N = Z(x), j = N.useKeysAsHeaders ? Object.keys(A[0]) : N.columnHeaders;
  let G = K(Y(""), L(N), P(N), R(N, j), E(N, j, A));
  if (z(G).length < 1) throw new _("Output is empty. Is your data formatted correctly?");
  return G;
};
var Ix = (x) => (A) => {
  if (!window) throw new M("Downloading only supported in a browser environment.");
  const N = Z(x), j = z(A), G = N.useTextFile ? "plain" : "csv", J = N.useTextFile ? "txt" : "csv";
  let U = new Blob([j], { type: `text/${G};charset=utf8;` }), I = document.createElement("a");
  I.download = `${N.filename}.${J}`, I.href = URL.createObjectURL(U), I.setAttribute("visibility", "hidden"), document.body.appendChild(I), I.click(), document.body.removeChild(I);
};
export {
  y as asString,
  Ix as download,
  Gx as generateCsv,
  Z as mkConfig
};
//# sourceMappingURL=export-to-csv.js.map
